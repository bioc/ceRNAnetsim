---
title: "Perturbation Efficiency in A Sample Dataset"
author: "Selcen Ari"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{How to Determine Perturbation in A Sample Dataset}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## What is perturbation efficiency?

The perturbation efficiency means that the disturbance and propagation efficiency of an element in the network. In a given network not all nodes have same or similar perturbation efficiency. Changes in some nodes might propagate to whole network and for some nodes the effect might be limited to small subgraph of the network. Not only topology but also miRNA:target interaction dynamics determine perturbation efficiency.

- Expression level and type of trigger element plays a crucial role. The trigger element can be an miRNA or competing target. The perturbation efficiency is affected from ratio of miRNA amount to sum of expression levels of its targets. Also, amount of competing element among whole competing elements is important since it determines distribution of miRNA. For example, if trigger is an miRNA with expression level of 1500 and if sum of expression levels of its targets is 1000000, then this miRNA will not perturb its neighborhood efficiently. So, miRNA:target ratio is important for regulation of interaction network.

- In a biological system, the miRNA:target interactions does not depend solely on stoichiometry, unfortunately. miRNAs affect the targets via degradation or inhibition after the binding. The experimental studies have shown that the features of miRNA:target interactions determine the binding and degradation efficiency. For example, binding energy between miRNA and target and seed structure of miRNA determine the binding efficiency of complex. In addition, the binding region on the target affects the degradation of target. 

- On the other hand, interaction factors affecting binding and degradation of miRNA to its targets also have impact one efficiency of perturbation of the change. For instance, if a node has very low binding affinity to targeting miRNA, change in expression level of that node will cause weak or no perturbation.

Thus, we developed functions which can calculate perturbation efficiency of a given node or all nodes. `calc_perturbation()` function calculates perturbation efficiency for given trigger (*e.g.* Gene17 2-fold). `find_node_perturbation()` function screens the whole network and calculate perturbation efficiency of all nodes.

## Load the *midsamp*

```{r, echo=FALSE, message= FALSE, warning=FALSE}
library(png)
```

```{r message=FALSE}
# install.packages("devtools")
# devtools::install_github("selcenari/ceRNAnetsim")
library(ceRNAnetsim)
data("midsamp")
midsamp
```

## How does the `calc_perturbation()` work?

This function works for a given node from network. It calculates and returns two values:

* **perturbation efficiency** : mean of percentage of expression changes of all elements except trigger in the network 
* **perturbed count** : count of disturbed nodes for given iteration number and limit (the minimum change in expression level needed to be considered "disturbed" or "changed"). 

In the example below, "Gene17" is up-regulated 3-fold in *midsamp* dataset where `Energy` and `seeds` columns are used for calculating affinity effect and `targeting_region` columns is used for calculating degradation effect. The network will be iterated over 30 times and number of disturbed nodes (as taking into account nodes that have changed more than the value of the threshold (0.1 percentage in terms of the change)) will be counted.


```{r}
midsamp %>%
  priming_graph(competing_count = Gene_expression, 
                miRNA_count = miRNA_expression,
                aff_factor = c(Energy,seeds), 
                deg_factor = targeting_region) %>%
  calc_perturbation("Gene17", 3, cycle = 30, limit = 0.1)
```

If you are interested in testing various fold change values of a given node, then we can use `map` (actually parallelized version `future_map`) to run function for set of input values.

First, let's keep the primed version of graph in an object

```{r}
primed_mid <- midsamp %>%
  priming_graph(competing_count = Gene_expression, 
                miRNA_count = miRNA_expression,
                aff_factor = c(Energy,seeds), 
                deg_factor = targeting_region)
```

Now, let's calculate perturbation efficiency caused by 2-fold to 10-fold increase in Gene17

```{r}
plan(multiprocess)  # for parallel processing

seq(2,10) %>%
  set_names() %>% 
  future_map_dfr(~ primed_mid %>% calc_perturbation("Gene17", .x, cycle = 30, limit = 0.1), .id="fold_change")
```

If you're interested in screening nodes instead of fold changes then you don't have to write a complicated `map` command, there's already a function available for that purpose.

## How does the `find_node_perturbation()` work?

The `find_node_perturbation()` function calculates the perturbation efficiency and perturbed node count of each node in network. 

In the example below, each node is increased 2-fold and tested for perturbation efficiency for 4 cycles with threshold of 0.1

```{r}
midsamp %>%
  priming_graph(competing_count = Gene_expression,
                miRNA_count = miRNA_expression,
                aff_factor = c(Energy,seeds),
                deg_factor = targeting_region) %>%
  find_node_perturbation(how = 3, cycle = 4, limit = 0.1)%>%
  select(name, perturbation_efficiency, perturbed_count)
```

On the other hand, some of nodes in network might not be affected from perturbation because of low expression or weak interaction factors. In this case, `fast` argument can be used. Argument `fast` calculate affected expression percent of the targets and perturbation calculation is not ran for these elements in network, if that percentage value is smaller than given `fast` value.

```{r}
midsamp %>%
  priming_graph(competing_count = Gene_expression,
                miRNA_count = miRNA_expression,
                aff_factor = c(Energy,seeds),
                deg_factor = targeting_region) %>%
  find_node_perturbation(how = 3, cycle = 4, limit = 0.1, fast=5)%>%
  select(name, perturbation_efficiency, perturbed_count)
```

The results of the `find_node_perturbation()` will list effectiveness or importance of nodes in the network. This function can help selecting nodes which will have effective perturbation in network.

## What are the limitations?

`find_node_perturbation()` runs `calc_perturb` on all nodes in the network in parallel with help of the `future` and `furrr` packages. In this vignette, the function is demonstrated on the `midsamp` data. This dataset is not comparable to actual biological miRNA:target gene datasets in size and complexity. Although `find_node_perturbation()` runs in parallel it might take long time to run in real huge biological datasets.
