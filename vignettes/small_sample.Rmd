---
title: "Approach of the Method in A Small Sample"
author: "Selcen Ari"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Demonstration of the Method in A Small Sample}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

```


# Introduction

This vignette demonstrates how to analyse miRNA:Competing interactions via `ceRNAnetsim` package. The perturbations in the miRNA:target interactions are handled step by step in `ceRNAnetsim`. The package calculates and simulates regulation of miRNA:competing RNA interactions based on amounts of miRNA and the targets and interaction factors.

The `ceRNAnetsim` works by executing following steps:

- The input dataset is prepared for analysis. The first variable is arranged as competing and the second as miRNA.
- The dataset is primed with `priming_graph()` function so that it's converted into a graph. This function makes calculations that are depended on miRNA amount, target (competing) amount and the interaction factors. It determines the efficiency of miRNA to each target and saves that values as egde data. All calculations are performed in edge data. After that, results of calculations are used in node data.
- The calculated values in edge are carried to node data through `update_nodes()` function. Note that the function should be used with `once = TRUE` argument after the `priming_graph()`.
- Now, the change in expression level of either miRNA or competing RNA can be introduced with `update_variables()` or `update_how()` functions.
- The change is perceived as a trigger and network-wise calculations are performed.
- The trigger is used for simulation of regulations in `simulate()` or `simulate_vis()`.
- These processes can generate various outputs such as graphs or graph objects.


The workflow of `ceRNAnetsim` are shown as following:

```{r pressure, echo=FALSE, fig.align='center', fig.width=4, fig.height=3, dpi=120}

knitr::include_graphics("gifs/model_vignette.png")
```

## Installation of ceRNAnetsim

```{r, message=FALSE,warning=FALSE}
#install.packages("devtools")
#devtools::install_github("selcenari/ceRNAnetsim")

library(ceRNAnetsim)
```

```{r, echo=FALSE, message= FALSE, warning=FALSE}
library(rlang)
library(dplyr)
library(tidyr)
library(stringr)
library(stringi)
library(tidyverse)
library(ggplot2)
library(tidygraph)
library(igraph)
library(ggraph)
library(purrr)
library(future)
library(furrr)
library(png)
library(extrafont)
```

## Load the *minsamp*

In this vignette, the model functions are demonstrated with minimal sample dataset.
*minsamp* is a sample dataset that includes 6 genes, 2 miRNAs and interaction factors of miRNA:gene pairs.

```{r}
data("minsamp")

minsamp
```

### About preparing data

The table used in minimal sample might look complicated thus let's see how it's constructed.

The table is actually constructed by merging three different tables:

* gene expression data
* miRNA expression data
* miRNA:gene pairs (might **optionally** contain data about the interaction)

So, the `minsamp` table is constructed by merging following tables:

```{r echo=FALSE}
# datapasta::tribble_paste()
gene_expression <- tibble::tribble(
                  ~competing, ~Competing_expression,
                     "Gene1",                 10000,
                     "Gene2",                 10000,
                     "Gene3",                  5000,
                     "Gene4",                 10000,
                     "Gene5",                  5000,
                     "Gene6",                 10000
                  )
```

```{r}
gene_expression
```

```{r echo=FALSE}
# datapasta::tribble_paste()
mirna_expression <- tibble::tribble(
                             ~miRNA, ~miRNA_expression,
                             "Mir1",              1000,
                             "Mir2",              2000
                             )
```

```{r}
mirna_expression
```

Third table should contain miRNA:gene interactions. This table can be as simple as

```{r echo=FALSE}
#datapasta::tribble_paste()
interaction_simple <- tibble::tribble(
                     ~competing, ~miRNA,
                        "Gene1", "Mir1",
                        "Gene2", "Mir1",
                        "Gene3", "Mir1",
                        "Gene4", "Mir1",
                        "Gene4", "Mir2",
                        "Gene5", "Mir2",
                        "Gene6", "Mir2"
                     )
```

```{r}
interaction_simple
```

or it can contain extra information about each miRNA:gene interaction

```{r echo=FALSE}
#datapasta::tribble_paste()
interaction_complex <-tibble::tribble(
     ~competing, ~miRNA, ~seed_type, ~region, ~energy,
        "Gene1", "Mir1",       0.43,     0.3,     -20,
        "Gene2", "Mir1",       0.43,    0.01,     -15,
        "Gene3", "Mir1",       0.32,     0.4,     -14,
        "Gene4", "Mir1",       0.23,     0.5,     -10,
        "Gene4", "Mir2",       0.35,     0.9,     -12,
        "Gene5", "Mir2",       0.05,     0.4,     -11,
        "Gene6", "Mir2",       0.01,     0.8,     -25
     )
```

```{r}
interaction_complex
```

By joining these 3 different tables, third table being simple or complex, your data will be ready for analysis.

## How to convert the dataset to graph

minimal sample `minsamp` is processed with `priming_graph()` function in first step. This provides conversion of dataset from data frame to graph object. This step comprises of:

- The competing elements (Genes in *minsamp*) are grouped according to the miRNAs they are associated with.
- In graph object, the **optional** interaction factors are processed and graded within the groups.
- The amounts (expressions) of miRNAs are distributed according to competing:total competing ratio.
- miRNA efficiency in steady-state is calculated by taking into account of expression distribution and effecting factors. The **optional** factors might have two types of effect; 1) affinity, 2) degree(?) effect. Any column which has effect on affinity should be provided as a vector to `aff_factor` argument. 

```{r}
priming_graph(minsamp, 
              competing_count = Competing_expression, 
              miRNA_count = miRNA_expression,
              aff_factor = c(energy, seed_type), 
              deg_factor = region)
```

## How to process edge data as node variables

In the processed data, the values are carried as node variables with `update_nodes(once=TRUE)`. This function defines variable types, hence the `type` column. In addition to `type` column, many more columns are initialized which are to be used in subsequent steps.

```{r}
minsamp %>%
   priming_graph(competing_count = Competing_expression, 
                 miRNA_count = miRNA_expression,
                 aff_factor = c(energy, seed_type), 
                 deg_factor = region) %>%
   update_nodes(once=TRUE)
```

## The change in the graph object

In the steady-state, the mirna efficiency are assumed as stable (ie. in equilibrium). But, if one or more nodes have altered expression level, the system tends to reach steady-state again. 

The `ceRNAnetsim` package utilizes two methods to simulate change in data. `update_variables()` and `update_how()` functions provide a trigger that can start the unsteady-state. 

The update_variables: An additional dataset with equal number of nodes is used. The dataset includes changed and unchanged values of node amounts. 

Firstly load the `new_count` (current_count dataset of minsamp):

```{r}
data(new_counts) #The Competing_count of Gene2 node is increased two fold.)

new_counts

```

### The change in dataset: Method 1

`update_variables()` replaces the changed values with previous values. The function checks all values of the given dataset, so it allows more than one change. 

```{r}
minsamp %>%
   priming_graph(competing_count = Competing_expression, 
                 miRNA_count = miRNA_expression,
                 aff_factor = c(energy, seed_type), 
                 deg_factor = region) %>%
   update_nodes(once=TRUE) %>%
   update_variables(current_counts = new_counts)%>%
   update_nodes()
```


### The change in dataset: Method 2

The other method is the change in given node name with `update_how()`. If the user wants to apply the change in single node, `update_how()` could be used. In the example below, expression level of Gene3 is increased 2-fold.
  
```{r}
minsamp %>%
   priming_graph(competing_count = Competing_expression, 
                 miRNA_count = miRNA_expression,
                 aff_factor = c(energy, seed_type), 
                 deg_factor = region) %>%
   update_nodes(once=TRUE) %>%
   update_how(node_name = "Gene3", how = 2)
```

(TOFIX yine ayný soru, Gene3 deðeri 10000 olmasý gerekmiyor muydu?)


## Update the node variables again (TOFIX neden bir daha deðiþiklik?)

The node variables updates again after the change in edge. This step are applied for easy tracking.

```{r}
minsamp %>%
   priming_graph(competing_count = Competing_expression, 
                 miRNA_count = miRNA_expression,
                 aff_factor = c(energy, seed_type), 
                 deg_factor = region) %>%
   update_nodes(once=TRUE) %>%
   update_variables(current_counts = new_counts) %>%
   update_nodes()

#or

minsamp %>%
   priming_graph(competing_count = Competing_expression, 
                 miRNA_count = miRNA_expression,
                 aff_factor = c(energy, seed_type), 
                 deg_factor = region) %>%
   update_nodes(once=TRUE) %>%
   update_how("Gene2", how = 2) %>%
   update_nodes()

```

## Simulate the model

When the change in expression level of a gene is applied to the interaction network, due of disruption in the interactions of miRNA:target ratios in groups, the steady-state conditions are assumed to be perturbed. So, the system tends to reach steady-state again. The change triggers the changes of other interactions in network, and then the rearrangement continues until the reaching steady-state.

With `simulate()` function the changes in the system, are calculated continuously.

```{r}

minsamp %>%
   priming_graph(competing_count = Competing_expression, 
                 miRNA_count = miRNA_expression,
                 aff_factor = c(energy, seed_type), 
                 deg_factor = region) %>%
   update_nodes(once=TRUE) %>%
   update_variables(current_counts = new_counts) %>%
   update_nodes() %>%
   simulate(cycle=10)

```

`simulate()` saves the variables of each iteration in lists that are found in edge data of graph. The changes in variables can be monitored in lists with using basic `dplyr` functions. For example:
  
```{r}
minsamp %>%
   priming_graph(competing_count = Competing_expression, 
                 miRNA_count = miRNA_expression,
                 aff_factor = c(energy, seed_type), 
                 deg_factor = region) %>%
   update_nodes(once=TRUE) %>%
   update_variables(current_counts = new_counts) %>%
   update_nodes() %>%
   simulate(cycle=10) %>%
   activate(edges)%>%       #from tidygraph package 
   select(comp_count_list, mirna_count_list)
```

Here, `comp_count_list` and `mirna_count_list` are list-columns which track changes in both competing RNA and miRNA levels.

## Visualisation of the graph

The `vis_graph` is used for visualisation of the graph object. The initial graph object (steady-state) is visualized as following:
  
```{r, fig.height=4, fig.width=5, warning=FALSE, dpi= 120, fig.align='center'}
minsamp %>%
   priming_graph(competing_count = Competing_expression, 
                 miRNA_count = miRNA_expression,
                 aff_factor = c(energy, seed_type), 
                 deg_factor = region) %>%
   update_nodes(once=TRUE) %>%
   vis_graph(title = "Minsamp initial Graph")
```

(TOFIX minsamp olmasýna raðmen bende bu iþlem epey uzu sürdü.)

Also, The graph can be visualized at any step of process, for example, after simulation of step 3.

```{r, fig.height=4, fig.width=5, warning=FALSE, dpi= 120, fig.align='center'}
minsamp %>%
   priming_graph(competing_count = Competing_expression, 
                 miRNA_count = miRNA_expression,
                 aff_factor = c(energy, seed_type), 
                 deg_factor = region) %>%
   update_nodes(once=TRUE) %>%
   update_variables(current_counts = new_counts) %>%
   update_nodes() %>%
   simulate(3) %>%
   vis_graph(title = "Minsamp Graph After 3 Iteration")
```

On the other hand, the view of each steps can be obtained by using `simulate_vis()` separately. `simulate_vis` processes the given graph like in `simulate()` and gives the views of each step.
  
```{r, fig.height=4, fig.width=5, warning=FALSE, message=FALSE, fig.show='hide'}
minsamp %>%
   priming_graph(competing_count = Competing_expression, 
                 miRNA_count = miRNA_expression,
                 aff_factor = c(energy, seed_type), 
                 deg_factor = region) %>%
   update_nodes(once=TRUE) %>%
   update_variables(current_counts = new_counts)%>%
   update_nodes()%>%
   simulate_vis(3, title = "Minsamp Graph After Each Iteration")
```

![Minsamp with 3 iteration](gifs/small_sample.gif)

 See the other vignettes for more information.
